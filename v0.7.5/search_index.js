var documenterSearchIndex = {"docs":
[{"location":"background_contact/contact_models.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"Impact and friction behaviors are modeled, along with the system’s dynamics, as a nonlinear complementarity problem (NCP). This model simulates hard contact without requiring system-specific solver tuning. Additionally, contacts between a system and the environment are treated as a single graph node connected to a rigid body (see below). As a result, the simulator retains efficient linear-time complexity for open-chain mechanical systems.","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"(Image: graph)","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"Three contact models are implemented in Dojo:","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"ImpactContact enforces frictionless contact,\nNonlinearContact enforces contact with a non-linear cone of friction (second-order cone),","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"(Image: nonlinear_cone)","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"LinearContact enforces contact with a linearized cone of friction (pyramidal cone).","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"(Image: linearized_cone)","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"All 3 of these contact models implement hard contact i.e., no interpenetration. This means that for both the nonlinear and linearized cones, we concatenate the constraints resulting from friction with the impact constraints.","category":"page"},{"location":"background_contact/contact_models.html#Implementation","page":"Overview","title":"Implementation","text":"","category":"section"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"Dojo currently supports contact constraints occurring between a sphere and the ground i.e., a horizontal half-space of altitude 0.0. Each spherical contact is attached to a single Body.","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"To create a new point of contact, we need to define:","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"the Body to which the contact constraint is attached\nradius of the sphere defining the spherical contact\ncoefficient of friction (except for ImpactContact)","category":"page"},{"location":"background_contact/contact_models.html#Example","page":"Overview","title":"Example","text":"","category":"section"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"For the Quadruped model shown in the picture below, we defined 12 contacts spheres show in red:","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"4 for the feet,\n4 for the knees,\n4 for for the hips.","category":"page"},{"location":"background_contact/contact_models.html","page":"Overview","title":"Overview","text":"(Image: quadruped_contact)","category":"page"},{"location":"background_representations/maximal_representation.html#Maximal-Coordinates","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"","category":"section"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"The i-th body in a mechanism with N bodies has state:  ","category":"page"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"z^(i) = (x^(i) v^(i) q^(i) omega^(i)) in mathbfR^3 times mathbfR^3 times mathbfH times mathbfR^3","category":"page"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"represented in maximal coordinates, where mathbfH is the space of unit quaternions. ","category":"page"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"x: position in world frame\nv: linear velocity in the world frame\nq: orientation represented as a unit quaternion\nomega: angular velocity in the body frame","category":"page"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"The mechanism state:   ","category":"page"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"z = (z^(1) dots z^(N))","category":"page"},{"location":"background_representations/maximal_representation.html","page":"Maximal Coordinates","title":"Maximal Coordinates","text":"is the concatentation of all body states.","category":"page"},{"location":"examples/system_identification.html#System-Identification","page":"System Identification","title":"System Identification","text":"","category":"section"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"A real-world dataset is used to learn the geometric and friction properties of a block being tossed onto a flat surface. Gradient-based optimization is employed to regress parameters and real-to-sim validation is performed. The ground truth system is shown in orange and the learned system in blue.","category":"page"},{"location":"examples/system_identification.html#Geometry","page":"System Identification","title":"Geometry","text":"","category":"section"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"<img src=\"../assets/animations/box_learning.gif\" width=\"300\"/>","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"The eight locations of the block's corners relative to its center of mass are learned.","category":"page"},{"location":"examples/system_identification.html#Friction","page":"System Identification","title":"Friction","text":"","category":"section"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"<img src=\"../assets/animations/cone_learning.gif\" width=\"200\"/>","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"A friction coefficient, describing a friction cone, is learned for all of the contact points.","category":"page"},{"location":"examples/system_identification.html#Real-To-Sim","page":"System Identification","title":"Real-To-Sim","text":"","category":"section"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"<img src=\"../assets/animations/box_toss.gif\" width=\"300\"/>","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"The system parameters are learned to within a pm 5  error from their ground-truth values. These parameters are then compared to the ground-truth system in simulation.","category":"page"},{"location":"examples/system_identification.html#Learning","page":"System Identification","title":"Learning","text":"","category":"section"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"The cost function: ","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"mathcalL(mathcalD theta) = sum_Z in mathcalD L(Z theta) = sum_Z in mathcalD frac12 s(z_- z theta) - z_+_W^2,","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"is used where mathcalD is a dataset of trajectories containing tuples (z_- z z_+) of state sequences, with system parameters theta in mathbfR^p, and where s  mathbfZ times mathbfZ times mathbfR^p rightarrow mathbfZ represents the simulator.","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"A quasi-Newton method is employed to optimize the cost function and uses gradients:","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"fracpartial Lpartial theta = fracpartial spartial theta^T W Big(s(z_- z theta) - z_+ Big),","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"and the following Gauss-Newton approximation: ","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"fracpartial^2 Lpartial theta^2 approx fracpartial spartial theta^T W fracpartial spartial theta,","category":"page"},{"location":"examples/system_identification.html","page":"System Identification","title":"System Identification","text":"of the cost function Hessian, which only relies on Jacobians from Dojo.","category":"page"},{"location":"background_contact/linearized_friction.html#Linearized-Friction","page":"Linearized Friction","title":"Linearized Friction","text":"","category":"section"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"Coulomb friction instantaneously maximizes the dissipation of kinetic energy between two objects in contact.","category":"page"},{"location":"background_contact/linearized_friction.html#Mathematical-Model","page":"Linearized Friction","title":"Mathematical Model","text":"","category":"section"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"For a single contact point, this physical phenomenon can be modeled by the following optimization problem,","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"beginalign*\nundersetbtextminimize  quad v^T b \ntextsubject to    quad b_2 leq mu gamma\nendalign*","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"where v in mathbfR^2 is the tangential velocity at the contact point, b in mathbfR^2 is the friction force, and mu in mathbfR_+ is the coefficient of friction between the two objects.","category":"page"},{"location":"background_contact/linearized_friction.html#Linearized-Model","page":"Linearized Friction","title":"Linearized Model","text":"","category":"section"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"This above problem is naturally a convex second-order cone program, and can be efficiently and reliably solved. However, classically, an approximate version:","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"beginalign*\nundersetbetatextminimize  quad v^T  -v^T beta \ntextsubject to        quad beta^T mathbf1 leq mu gamma \n                         quad beta geq 0\nendalign*","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"which satisfies the LCP formulation, is instead solved. Here, the friction cone is linearized and the friction vector, beta in mathbfR^4, is correspondingly overparameterized and subject to additional non-negative constraints.","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"The optimality conditions of the above problem and constraints used in the LCP are:","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"beginalign*\nv^T  -v^T^T + psi mathbf1 - eta = 0 \nmu gamma -beta^T textbf1  geq 0\npsi cdot (mu gamma - beta^T textbf1) = 0 \nbeta circ eta = 0 \nbeta psi eta geq 0\nendalign*","category":"page"},{"location":"background_contact/linearized_friction.html","page":"Linearized Friction","title":"Linearized Friction","text":"where psi in mathbfR and eta in mathbfR^4 are the dual variables associated with the friction cone and positivity constraints, respectively, and textbf1 is a vector of ones.","category":"page"},{"location":"contributing.html#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Contributions are always welcome!","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"If you want to contribute features, bug fixes, etc, please take a look at our Code Style Guide below\nPlease report any issues and bugs that you encounter in Issues\nAs an open source project we are also interested in any projects and applications that use Dojo. Please let us know via email to: thowell@stanford.edu or simonlc@stanford.edu","category":"page"},{"location":"contributing.html#Potentially-Useful-Contributions","page":"Contributing","title":"Potentially Useful Contributions","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Here are a list of current to-do's that would make awesome contributions:","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"reduce allocations by using StaticArrays and https://docs.julialang.org/en/v1/manual/profile/#Line-by-Line-Allocation-Tracking\nimproved parsing of URDF files\njoint limits, friction coefficients\nimproved collision detection \nbody-to-body contact \ngeneral convex shapes \ncurved surfaces \nGPU support \nnice REPL interface\ninteractive GUI","category":"page"},{"location":"contributing.html#Code-Style-Guide","page":"Contributing","title":"Code Style Guide","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"The code in this repository follows the naming and style conventions of Julia Base with a few modifications. This style guide is heavily \"inspired\" by the guides of John Myles White, JuMP, and COSMO","category":"page"},{"location":"contributing.html#Formatting","page":"Contributing","title":"Formatting","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use one tab when indenting a new block (except module)\nUse spaces between operators, except for ^, ', and :\nUse single space after commas and semicolons\nDon't use spaces around parentheses, or braces","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: f(x,y) = [5*sin(x+y);y'] Good: f(x, y) = [5 * sin(x + y); y']","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use spacing with keyword arguments","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: foo(x::Float; y::Integer = 1) Good: foo(x::Float; y::Integer=1)","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Don't parenthesize conditions","category":"page"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Bad: if (a == b) Good: if a == b","category":"page"},{"location":"contributing.html#Naming","page":"Contributing","title":"Naming","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Modules and Type names use capitalization and camel case, e.g. module LinearAlgebra, struct ConvexSets.\nFunctions are lowercase and use underscores to separate words, e.g. has_key(x), is_valid(y).\nNormal variables are lowercase and use underscores like functions, e.g. convex_set\nConstants are uppercase, e.g. const MY_CONSTANT\nAlways append ! to names of functions that modify their arguments.\nFunction arguments that are mutated come first. Otherwise follow the rules layed out in Julia Base Argument ordering\nFiles are named like functions, e.g. my_new_file.jl","category":"page"},{"location":"contributing.html#Syntax","page":"Contributing","title":"Syntax","text":"","category":"section"},{"location":"contributing.html","page":"Contributing","title":"Contributing","text":"Use 1.0 instead of 1.","category":"page"},{"location":"background_solver/solver_options.html#Solver-Options","page":"Solver Options","title":"Solver Options","text":"","category":"section"},{"location":"background_solver/solver_options.html","page":"Solver Options","title":"Solver Options","text":"The solver has several options accessible via SolverOptions. Below is a list describing their effect on the solver's behavior, typical values, and if they need to be tuned by the user.","category":"page"},{"location":"background_solver/solver_options.html","page":"Solver Options","title":"Solver Options","text":"option default range effect tuning\nrtol 10^-4 10^-6 10^-2 larger leads to faster solve (usually takes the same value as btol) rarely\nbtol 10^-4 10^-6 10^-2 larger results in smoothed contact dynamics and faster solve rarely\nls_scale 05 03 08 larger potentially increase step size at the cost of more residual evaluations never\nmax_ls 10 1 25 larger allows for taking smaller steps never\nundercut +infty 2 +infty larger is more robust but can generate stiffer gradients rarely\nno_progress_max 3 3 5 smaller will increase the undercut faster never\nno_progress_undercut 10 3 100 larger will increase the undercut faster never\nverbose textfalse texttrue textfalse printing the status of the solver often","category":"page"},{"location":"examples/simulation.html#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"Dojo can simulate a number of interesting physical behaviors.  We include notebooks (generated upon installation) for the examples below.","category":"page"},{"location":"examples/simulation.html#Atlas-Drop","page":"Simulation","title":"Atlas Drop","text":"","category":"section"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"../assets/animations/atlas_drop.gif\" width=\"100\"/>","category":"page"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"The humanoid Atlas is dropped onto a flat surface.  Dojo is able to simulate hard contact and prevent interpenetration of the robot's feet with the floor. In comparison, when the same system is simulated in MuJoCo, centimeters of interpenetration occur.","category":"page"},{"location":"examples/simulation.html#Friction-Cone-Comparison","page":"Simulation","title":"Friction Cone Comparison","text":"","category":"section"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"../assets/animations/cone_compare_mujoco.gif\" width=\"300\"/>","category":"page"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"Blocks are simulated with initial velocity before impacting and sliding along a flat surface. We compare Dojo's nonlinear cone (blue) with a linearized approximation (orange) and MuJoCo's default linear cone (magenta). The linearized cones exhibit drift due to the approximation, whereas Dojo's nonlinear cone produces the expected sliding behavior.","category":"page"},{"location":"examples/simulation.html#Dzhanibekov-Effect","page":"Simulation","title":"Dzhanibekov Effect","text":"","category":"section"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"../assets/animations/dzhanibekov.gif\" width=\"150\"/>","category":"page"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"Dojo simulates the unstable rotational motion of a rigid body about its second primary moment of inertia. Using non-Euclidean optimization for quaternions enables continuous simulation of rotating objects without singularity issues.","category":"page"},{"location":"examples/simulation.html#Tippetop","page":"Simulation","title":"Tippetop","text":"","category":"section"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"<img src=\"../assets/animations/tippetop.gif\" width=\"300\"/>","category":"page"},{"location":"examples/simulation.html","page":"Simulation","title":"Simulation","text":"A spinning object oscillates between up and down configurations as a result of its mass distribution.","category":"page"},{"location":"creating_mechanism/environment_existing.html#Using-an-Existing-Environment","page":"Using an Existing Environment","title":"Using an Existing Environment","text":"","category":"section"},{"location":"creating_mechanism/environment_existing.html","page":"Using an Existing Environment","title":"Using an Existing Environment","text":"The following code uses a function defined in DojoEnvironments to create a pendulum Environment. This Environment is a wrapper around the Mechanism for easy interfacing with other packages. As with Mechanisms, you can use the existing templates as a starting point for your own Environments.","category":"page"},{"location":"creating_mechanism/environment_existing.html","page":"Using an Existing Environment","title":"Using an Existing Environment","text":"# ### Setup\nusing Dojo\nusing DojoEnvironments\n\n# ### Get environment (check DojoEnvironment/environments files for kwargs)\nenvironment = get_environment(:pendulum; timestep=0.01, horizon=200) ","category":"page"},{"location":"examples/trajectory_optimization.html#Trajectory-Optimization","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"info: Info\nThe trajectory optimization examples are outdated and currently not available.","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"Dojo provides dynamics constraints and Jacobians in order to perform trajectory optimization using iterative LQR. ","category":"page"},{"location":"examples/trajectory_optimization.html#Quadruped","page":"Trajectory Optimization","title":"Quadruped","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"../assets/animations/quadruped_min.gif\" width=\"200\"/>","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"A Unitree A1 takes a number of forward steps. There are costs on a kinematic gait and control usage, as well as an augmented Lagrangian (i.e., soft) constraint on the the robot's final pose. The maximal representation is converted to a minimal one for optimization. Additionally, slack controls are utilized early on to aid the optimizer before being driven to zero by a constraint to achieve a dynamically feasible trajectory.","category":"page"},{"location":"examples/trajectory_optimization.html#Atlas","page":"Trajectory Optimization","title":"Atlas","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"../assets/animations/atlas_ilqr.gif\" width=\"200\"/>","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"The Atlas v5 humanoid (sans arms) takes a number of forward steps. Similar to the quadruped example, there are costs on control effort and deviations from a kinematic plan, a minimal representation is utilized, and the optimizer is aided by slack controls.","category":"page"},{"location":"examples/trajectory_optimization.html#Block","page":"Trajectory Optimization","title":"Block","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"../assets/animations/box_right.gif\" width=\"200\"/>","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"A block is moved to a goal location by applying forces to its center of mass. The optimizer is initialized with zero control and utilizes smooth gradients from Dojo to find a motion that overcomes friction to slide towards the goal.","category":"page"},{"location":"examples/trajectory_optimization.html#Raibert-Hopper","page":"Trajectory Optimization","title":"Raibert Hopper","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"../assets/animations/hopper_max.gif\" width=\"100\"/>","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"A hopping robot, inspired by the Raibert Hopper, is tasked with moving to a goal location. The optimizer finds a single hop trajectory to reach its goal pose.","category":"page"},{"location":"examples/trajectory_optimization.html#Cartpole","page":"Trajectory Optimization","title":"Cartpole","text":"","category":"section"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"<img src=\"../assets/animations/cartpole_max.gif\" width=\"200\"/>","category":"page"},{"location":"examples/trajectory_optimization.html","page":"Trajectory Optimization","title":"Trajectory Optimization","text":"This classic system is tasked with performing a swing-up. Examples are provided performing optimization with both maximal and minimal representations. ","category":"page"},{"location":"creating_mechanism/overview.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"creating_mechanism/overview.html","page":"Overview","title":"Overview","text":"There are three ways to to build and use mechanical systems in Dojo: Build it directly, use an existing mechanism, or use an existing environment. Directly-built and existing mechanism both result in a Mechanism, and using an existing mechanism is just for convenience. Creating an Environment can be useful for more advanced applications like reinforcement learning. We use the pendulum as a simple example for these three methods and later give two more detailed examples.","category":"page"},{"location":"environments/overview.html#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"environments/overview.html","page":"Overview","title":"Overview","text":"You can use Environments to interface Dojo to other packages, such as ReinforcementLearning. Due to current changes in the ReinforcementLearning package, we will provide an updated documentation once the changes are done. However, an experimental implementation of training the cartpole with ReinforcementLearning is provided in the examples.","category":"page"},{"location":"examples/reinforcement_learning.html#Reinforcement-Learning","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"","category":"section"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"We have implemented a few learning examples.","category":"page"},{"location":"examples/reinforcement_learning.html#Ant","page":"Reinforcement Learning","title":"Ant","text":"","category":"section"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"<img src=\"../assets/animations/ant_ars.gif\" width=\"300\"/>","category":"page"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"Policy optimization is performed using the reinforcement-learning algorithm augmented random search (ARS) to optimize static linear policies for locomotion. The insect-like robot has rewards on forward velocity and survival and costs on control usage and contact forces.","category":"page"},{"location":"examples/reinforcement_learning.html#Quadruped","page":"Reinforcement Learning","title":"Quadruped","text":"","category":"section"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"<img src=\"../assets/animations/quadruped.gif\" width=\"300\"/>","category":"page"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"A very basic random-sampling algorithm is used to find parameters for the periodic gait of a quadruped. ","category":"page"},{"location":"examples/reinforcement_learning.html#Cartpole","page":"Reinforcement Learning","title":"Cartpole","text":"","category":"section"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"<img src=\"../assets/animations/cartpole_rl.gif\" width=\"300\"/>","category":"page"},{"location":"examples/reinforcement_learning.html","page":"Reinforcement Learning","title":"Reinforcement Learning","text":"We have modified the cartpole example in the ReinforcementLearning package to use Dojo's dynamics. This allows us to combine advanced learning algorithms with accurate dynamics simulation.","category":"page"},{"location":"background_contact/collisions.html#Collisions","page":"Collisions","title":"Collisions","text":"","category":"section"},{"location":"background_contact/collisions.html","page":"Collisions","title":"Collisions","text":"info: Info\nOnly sphere-halfspace collisions (spheres colliding with planes) are fully supported. The other contact models are experimental.","category":"page"},{"location":"background_contact/collisions.html","page":"Collisions","title":"Collisions","text":"Dojo currently implements the following collision models: ","category":"page"},{"location":"background_contact/collisions.html","page":"Collisions","title":"Collisions","text":"SphereHalfSpaceCollision\nSphereSphereCollision\nSphereCapsuleCollision\nSphereBoxCollision","category":"page"},{"location":"background_contact/collisions.html","page":"Collisions","title":"Collisions","text":"<img src=\"../assets/animations/sphere_capsule_drop.gif\" width=\"200\"/>","category":"page"},{"location":"background_contact/collisions.html","page":"Collisions","title":"Collisions","text":"<img src=\"../assets/animations/sphere_box_drop.gif\" width=\"200\"/>","category":"page"},{"location":"background_representations/minimal_representation.html#Minimal-Coordinates","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"","category":"section"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"Dojo simulates systems in maximal coordinates. ","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"For a mechanism with M joints and N bodies, the maximal representation z can be efficiently converted to minimal coordinates: ","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"y = (y^(1) dots y^(M)) leftarrow z = (z^(1) dots z^(N))","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"where y^(j) depends on the degree and type of joint. Note: this minimal representation does not stack coordinates followed by velocities, which is a common convention; instead, coordinates and velocities are grouped by joint.","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"Each minimal state comprises:","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"y = (p_texttranslational p_textrotational w_texttranslational w_textrotational)","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"coordinates p and velocities w for both translational and rotational degrees of freedom.","category":"page"},{"location":"background_representations/minimal_representation.html","page":"Minimal Coordinates","title":"Minimal Coordinates","text":"In the case of a floating-base joint, the minimal-representation orientation is converted to modified Rodrigues parameters from a unit quaternion.","category":"page"},{"location":"api.html#API-Documentation","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Docstrings for Dojo.jl interface members can be accessed through Julia's built-in documentation system or in the list below.","category":"page"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"CurrentModule = Dojo","category":"page"},{"location":"api.html#Contents","page":"API Documentation","title":"Contents","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Index","page":"API Documentation","title":"Index","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#Mechanism","page":"API Documentation","title":"Mechanism","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Mechanism\nget_node\nget_body\nget_joint\nget_contact\nget_maximal_state\nget_next_state\nget_minimal_state\nset_maximal_state!\nset_minimal_state!\nset_input!\nmaximal_dimension \nminimal_dimension\ninput_dimension\ninput_dimensions\nzero_coordinates!\nzero_velocities!\nroot_to_leaves_ordering\nset_floating_base\nset_external_force!\nadd_external_force!","category":"page"},{"location":"api.html#Dojo.Mechanism","page":"API Documentation","title":"Dojo.Mechanism","text":"Mechanism{T}\n\nMulti-rigid-body system. \n\norigin: global reference frame represented with Origin\njoints: list of JointConstraint objects\nbodies: list of Body objects\ncontacts: list of ContactConstraint objects\nsystem: graph-based representation for mechanism\nresidual_entries: containt entries for linear system residual\ndata_matrix: contains parameter information that is fixed during simulation\nroot_to_leaves: list of node connections traversing from root node to leaves\ntimestep: time discretization\ninput_scaling: input scaling for internal use of impulses (default: timestep)\ngravity: force vector resulting from gravitational potential\nμ: complementarity violation (contact softness)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.get_node","page":"API Documentation","title":"Dojo.get_node","text":"get_node(mechanism, name) \n\nreturn Node from Mechanism \n\nmechanism: Mechanism \nname: unique identifier for node\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_body","page":"API Documentation","title":"Dojo.get_body","text":"get_body(mechanism, name) \n\nreturns Body from Mechanism\n\nmechanism: Mechanism \nname: unique identifier for body\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_joint","page":"API Documentation","title":"Dojo.get_joint","text":"get_joint(mechanism, name) \n\nreturn JointConstraint from Mechanism \n\nmechanism: Mechanism \nname: unique identifier for joint\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_contact","page":"API Documentation","title":"Dojo.get_contact","text":"get_contact(mechanism, name) \n\nreturns ContactConstraint from Mechanism \n\nmechanism: Mechanism \nname: unique identifier for contact\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_maximal_state","page":"API Documentation","title":"Dojo.get_maximal_state","text":"get_maximal_state(mechanism) \n\nreturn the current maximal state of mechanism \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_next_state","page":"API Documentation","title":"Dojo.get_next_state","text":"get_next_state(mechanism) \n\nreturn the maximal state of mechanism after one simulation step\n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_minimal_state","page":"API Documentation","title":"Dojo.get_minimal_state","text":"get_minimal_state(mechanism) \n\nreturn minimal state for mechanism \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_maximal_state!","page":"API Documentation","title":"Dojo.set_maximal_state!","text":"set_maximal_state(mechanism, z) \n\nset the maximal state of a mechanism \n\nmechanism: Mechanism \nz: state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_minimal_state!","page":"API Documentation","title":"Dojo.set_minimal_state!","text":"set_minimal_state(mechanism, y) \n\nset the minimal state of a mechanism \n\nmechanism: Mechanism \ny: state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_input!","page":"API Documentation","title":"Dojo.set_input!","text":"set_input(mechanism, u) \n\nset input for each joint in mechanism \n\nmechanism: Mechanism \nu: input\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.maximal_dimension","page":"API Documentation","title":"Dojo.maximal_dimension","text":"maximal_dimension(mechanism)\n\ndimension of a mechanism's maximal representation\n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.minimal_dimension","page":"API Documentation","title":"Dojo.minimal_dimension","text":"minimal_dimension(mechanism)\n\ndimension of a mechanism's minimal representation\n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.input_dimension","page":"API Documentation","title":"Dojo.input_dimension","text":"input_dimension(mechanism)\n\nreturn the number of inputs for mechanism\n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.input_dimensions","page":"API Documentation","title":"Dojo.input_dimensions","text":"input_dimensions(mechanism)\n\nreturn an array with the input dimensions of all joints\n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.zero_coordinates!","page":"API Documentation","title":"Dojo.zero_coordinates!","text":"zero_coordinates!(mechanism) \n\nset all mechanism body coordinates to zero \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.zero_velocities!","page":"API Documentation","title":"Dojo.zero_velocities!","text":"zero_velocities!(mechanism) \n\nset all mechanism body velocities to zero \n\nmechanism: Mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.root_to_leaves_ordering","page":"API Documentation","title":"Dojo.root_to_leaves_ordering","text":"root_to_leaves_ordering(mechanism; exclude_origin, exclude_loop_joints)\n\nordered list of ids from root to leaves, all nodes are visited a single time\n    excluding: origin, joints forming a loop which are not visited\n\nmechanism: Mechanism \nexclude_origin: flag to exclude origin from traversal \nexclude_loop_joints: flag to exclude loop joints from traversal\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_floating_base","page":"API Documentation","title":"Dojo.set_floating_base","text":"set_floating_base(mechanism, name)\n\nreturns a mechanism with modified joints having body identified with 'name' as the floating base\n\nmechanism: Mechanism\nname: Symbol, identifier for floating-base body\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_external_force!","page":"API Documentation","title":"Dojo.set_external_force!","text":"set_external_force!(body; force, torque, vertex)\n\napplies an external force on a body\n\nbody: Body \nforce: force in body frame\ntorque: torque in local frame\nvertex: point where force is applied in local frame\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.add_external_force!","page":"API Documentation","title":"Dojo.add_external_force!","text":"add_external_force!(body; force, torque, vertex)\n\nadds an additional external force on a body\n\nbody: Body \nforce: force in body frame\ntorque: torque in local frame\n\n\n\n\n\n","category":"function"},{"location":"api.html#Nodes","page":"API Documentation","title":"Nodes","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Node\nBody\nOrigin\nConstraint\nShape\nEmptyShape\nMesh\nBox\nCylinder\nCapsule\nSphere\nPyramid\nFrameShape\nCombinedShapes","category":"page"},{"location":"api.html#Dojo.Node","page":"API Documentation","title":"Dojo.Node","text":"Node{T}\n\nAbstract type for graph node object\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Body","page":"API Documentation","title":"Dojo.Body","text":"Body{T} <: Node{T}\n\nA rigid body object\n\nid: unique identifying number \nname: unique identifying name \nmass: inertial property (kilograms)\ninertia: inertia matrix (kilograms meter^2)\nstate: State; representation of the system's: position, linear velocity, orientation, and angular velocity \nshape: Shape; geometry information about the Body\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Origin","page":"API Documentation","title":"Dojo.Origin","text":"Origin{T} <: Node{T}\n\nGlobal reference frame\n\nid: always 0 \nname: always :origin \nstate: State; defaults to zero values\nshape: Shape; defaults to EmptyShape\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Constraint","page":"API Documentation","title":"Dojo.Constraint","text":"Constraint{T}\n\nAbstract type for graph edge object\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Shape","page":"API Documentation","title":"Dojo.Shape","text":"Shape{T} \n\nAbstract type; Subtypes contain geometric and visual information for a Body.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.EmptyShape","page":"API Documentation","title":"Dojo.EmptyShape","text":"EmptyShape{T} <: Shape{T}\n\nContains no geometric or visual information\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Mesh","page":"API Documentation","title":"Dojo.Mesh","text":"Mesh{T} <: Shape{T}\n\nContains geometric and visual information based on .obj file\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Box","page":"API Documentation","title":"Dojo.Box","text":"Box{T} <: Shape{T}\n\nCuboid geometry \n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nxyz: dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Cylinder","page":"API Documentation","title":"Dojo.Cylinder","text":"Cylinder{T} <: Shape{T}\n\ncylinder geometry \n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nrh: radius and height dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Capsule","page":"API Documentation","title":"Dojo.Capsule","text":"Capsule geometry created as a CombinedShapes\n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nrh: radius and height dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Sphere","page":"API Documentation","title":"Dojo.Sphere","text":"Sphere{T} <: Shape{T}\n\nsphere geometry \n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nr: radius (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Pyramid","page":"API Documentation","title":"Dojo.Pyramid","text":"Pyramid{T} <: Shape{T}\n\npyramid geometry \n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nwh: width and height dimensions (meters)\nscale: scaling\ncolor: RGBA\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.FrameShape","page":"API Documentation","title":"Dojo.FrameShape","text":"FrameShape{T} <: Shape{T}\n\ncoordinate frame geometry \n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nscale: scaling\ncolor: not used\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.CombinedShapes","page":"API Documentation","title":"Dojo.CombinedShapes","text":"CombinedShapes{T} <: Shape{T}\n\ncomposite geometry\n\nposition_offset: geometry origin offset from center of mass\norientation_offset: orientation offset from body frame\nshape: list of Shape objects\nxyz: dimensions (meters)\n\n\n\n\n\n","category":"type"},{"location":"api.html#Joints","page":"API Documentation","title":"Joints","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Joint\nRotational\nTranslational\nJointConstraint\nFloating\nFixed\nPrismatic\nPlanar\nFixedOrientation\nRevolute\nCylindrical\nPlanarAxis\nFreeRevolute\nOrbital\nPrismaticOrbital\nPlanarOrbital\nFreeOrbital\nSpherical\nCylindricalFree\nPlanarFree","category":"page"},{"location":"api.html#Dojo.Joint","page":"API Documentation","title":"Dojo.Joint","text":"Joint{T}\n\nAbstract type for 3-dimensional constraint between two Body objects\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Rotational","page":"API Documentation","title":"Dojo.Rotational","text":"Rotational{T} <: Joint{T}\n\nconstraint limiting rotational degrees of freedom\n\naxis: rotation axis in parent offset frame\naxis_mask1: rotation axis mask in pbody's frame\naxis_mask2: rotation axis mask in pbody's frame\naxis_mask3: rotation axis mask in pbody's frame\norientation_offset: rotation axis offset from pbody's frame\nspring :coefficient for joint spring\ndamper: coefficient for joint damper\nspring_offset: nominal joint configuration\njoint_limits: lower and upper limits on the joint configuration\nspring_type: can be :linear or :sinusoidal (currently not implemented), if linear then we need joint_limits to avoid the 360° singularity.\ninput: external impulse torque\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Translational","page":"API Documentation","title":"Dojo.Translational","text":"Translational{T} <: Joint{T}\n\nconstraint limiting translational degrees of freedom\n\naxis: translational axis in parent offset frame\naxis_mask1: translational axis mask in pbody's frame\naxis_mask2: translational axis mask in pbody's frame\naxis_mask3: translational axis mask in pbody's frame\nvertices: points in parent can child frames\nspring: coefficient for joint spring\ndamper: coefficient for joint damper\nspring_offset: nominal joint configuration\njoint_limits: lower and upper limits on the joint configuration\nspring_type: can be :linear or :sinusoidal (currently not implemented), if linear then we need joint_limits to avoid the 360° singularity.\ninput: external impulse force\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.JointConstraint","page":"API Documentation","title":"Dojo.JointConstraint","text":"JointConstraint{T} <: Constraint{T}\n\nconstraint restricting translational and rotational degrees of freedom between two Body objects.\n\nid: a unique identifying number\nname: a unique identifying name\ntranslational: Translational\nrotational: Rotational\nspring: flag for joint springs on\ndamper: flag for joint dampers on\nparent_id: identifying number for parent Body{T}\nchild_id: identifying number for child Body{T}\nminimal_index: indices for minimal coordinates\nimpulses: joint impulses that maintain constraint between two Body{T} objects\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.Floating","page":"API Documentation","title":"Dojo.Floating","text":"Floating{T} <: JointConstraint{T} \n\nno restricted degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Fixed","page":"API Documentation","title":"Dojo.Fixed","text":"Fixed{T} <: JointConstraint{T}\n\nfixed connection between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Prismatic","page":"API Documentation","title":"Dojo.Prismatic","text":"Prismatic{T} <: JointConstraint{T}\n\none translational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Planar","page":"API Documentation","title":"Dojo.Planar","text":"Planar{T} <: JointConstraint{T} \n\ntwo translational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.FixedOrientation","page":"API Documentation","title":"Dojo.FixedOrientation","text":"FixedOrientation{T} <: JointConstraint{T} \n\nthree translational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Revolute","page":"API Documentation","title":"Dojo.Revolute","text":"Revolute{T} <: JointConstraint{T} \n\none rotational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Cylindrical","page":"API Documentation","title":"Dojo.Cylindrical","text":"Cylindrical{T} <: JointConstraint{T} \n\none translational and one rotational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PlanarAxis","page":"API Documentation","title":"Dojo.PlanarAxis","text":"PlanarAxis{T} <: JointConstraint{T} \n\ntwo translational and one rotational degree of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.FreeRevolute","page":"API Documentation","title":"Dojo.FreeRevolute","text":"FreeRevolute{T} <: JointConstraint{T} \n\nfree translation with rotation along one axis\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Orbital","page":"API Documentation","title":"Dojo.Orbital","text":"Orbital{T} <: JointConstraint{T} \n\ntwo rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PrismaticOrbital","page":"API Documentation","title":"Dojo.PrismaticOrbital","text":"PrismaticOrbital{T} <: JointConstraint{T} \n\none translational and two rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PlanarOrbital","page":"API Documentation","title":"Dojo.PlanarOrbital","text":"PlanarOrbital{T} <: JointConstraint{T} \n\ntwo translational and two rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.FreeOrbital","page":"API Documentation","title":"Dojo.FreeOrbital","text":"FreeOrbital{T} <: JointConstraint{T} \n\nthree translational and two rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Spherical","page":"API Documentation","title":"Dojo.Spherical","text":"Spherical{T} <: JointConstraint{T} \n\nthree rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.CylindricalFree","page":"API Documentation","title":"Dojo.CylindricalFree","text":"CylindricalFree{T} <: JointConstraint{T} \n\none translational and three rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.PlanarFree","page":"API Documentation","title":"Dojo.PlanarFree","text":"PlanarFree{T} <: JointConstraint{T} \n\ntwo translational and three rotational degrees of freedom between two bodies\n\n\n\n\n\n","category":"function"},{"location":"api.html#Contacts","page":"API Documentation","title":"Contacts","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Contact\nImpactContact\nLinearContact\nNonlinearContact\nContactConstraint\ncontact_constraint\ncontact_location\nget_sdf \nCollision\nSphereHalfSpaceCollision\nSphereSphereCollision\nSphereCapsuleCollision\nSphereBoxCollision\ncontact_normal \ncontact_tangent","category":"page"},{"location":"api.html#Dojo.Contact","page":"API Documentation","title":"Dojo.Contact","text":"Contact{T,N} \n\nAbstract type containing contact information associated with Body objects.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.ImpactContact","page":"API Documentation","title":"Dojo.ImpactContact","text":"ImpactContact{T,N} <: Contact{T,N}\n\ncontact object for impact (i.e., no friction)\n\ncollision: Collision\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.LinearContact","page":"API Documentation","title":"Dojo.LinearContact","text":"LinearContact{T,N} <: Contact{T,N}\n\ncontact object for impact and friction with a linearized friction cone\n\nfriction_coefficient: value of friction coefficient\ncollision: Collision\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.NonlinearContact","page":"API Documentation","title":"Dojo.NonlinearContact","text":"NonlinearContact{T,N} <: Contact{T,N}\n\ncontact object for impact and friction with a nonlinear friction cone\n\nfriction_coefficient: value of friction coefficient\ncontact_tangent: mapping from world frame to surface tangent frame \ncontact_normal: inverse/complement of contact_tangent\ncontact_origin: position of contact on Body relative to center of mass \ncontact radius: radius of contact\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.ContactConstraint","page":"API Documentation","title":"Dojo.ContactConstraint","text":"ContactConstraint{T} <: Constraint{T}\n\nconstraint containing information for contact node.\n\nid: unique identifying number \nname: unique identifying name \nmodel: type of contact model: ImpactContact, LinearContact, NonlinearContact \nparent_id: identifying number of Body experiencing contact \nchild_id: always 0\nimpulses: contact impulses applied to Body \nimpulses_dual: dual contact impulses, used by solver to enforce correct contact behaviors\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.contact_constraint","page":"API Documentation","title":"Dojo.contact_constraint","text":"contact_constraint(bodies::Vector{Body}) \n\ngenerate ContactConstraints for each Body in list\n\nnormals: surface normal for each contact point\nfriction_coefficients: value of coefficient of friction for each contact point (optional for ImpactContact)\ncontact_origins: the offset with respect to the center of Body for each contact point (optional)\ncontact_radius: radius for each contact (optional)\ncontact_type: :nonlinear, :linear, :impact\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.contact_location","page":"API Documentation","title":"Dojo.contact_location","text":"contact_location(contact, x, q)\n\nlocation of contact point in world coordinates\n\ncontact: ContactConstraint\nx: body position\nq: body orientation\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_sdf","page":"API Documentation","title":"Dojo.get_sdf","text":"get_sdf(contact, x, q)\n\nreturns the signed distance for a contact\n\ncontact: ContactConstraint\nx: body position\nq: body orientation\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.Collision","page":"API Documentation","title":"Dojo.Collision","text":"Collision\n\nabstract type defining interaction between two bodies\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.SphereHalfSpaceCollision","page":"API Documentation","title":"Dojo.SphereHalfSpaceCollision","text":"SphereHalfSpaceCollision \n\ncollision between a spherical contact and a flat surface\n\ncontact_tangent: mapping from world frame to surface tangent frame \ncontact_normal: inverse/complement of contact_tangent\ncontact_origin: position of contact on Body relative to center of mass \ncontact_radius: radius of contact\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.SphereSphereCollision","page":"API Documentation","title":"Dojo.SphereSphereCollision","text":"SphereSphereCollision \n\ncollision between two spheres\n\norigin_parent: position of contact on parent body relative to center of mass \norigin_child: position of contact on parent body relative to center of mass \nradius_parent: radius of contact for parent body \nradius_child: radius of contact for child body\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.SphereCapsuleCollision","page":"API Documentation","title":"Dojo.SphereCapsuleCollision","text":"SphereCapsuleCollision \n\ncollision between sphere and capsule \n\norigin_sphere:    position of sphere contact relative to body center of mass\norigin_capsule_a: position of capsule contact a relative to body center of mass\norigin_capsule_b: position of capsule contact b relative to body center of mass\nradius_sphere:    radius of sphere contact\nradius_capsule:   radius of capsule contact\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.SphereBoxCollision","page":"API Documentation","title":"Dojo.SphereBoxCollision","text":"SphereBoxCollision \n\ncollision between sphere and box \n\norigin_sphere:    position of sphere contact relative to body center of mass\norigin_box_a:     position of box corner contact a relative to body center of mass\norigin_box_b:     position of box corner contact b relative to body center of mass\nradius_sphere:    radius of sphere contact\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.contact_normal","page":"API Documentation","title":"Dojo.contact_normal","text":"contact_normal(collision, xp, qp, xc, qc)\n\nthe contact normal (from child to parent) between two contact points\n\ncollision: Collision\nxp: parent body position\nqp: parent body orientation\nxc: child body position\nqc: child body orientation\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.contact_tangent","page":"API Documentation","title":"Dojo.contact_tangent","text":"contact_tangent(collision, xp, qp, xc, qc)\n\ncontact tangents between two contact points\n\ncollision: Collision\nxp: parent body position\nqp: parent body orientation\nxc: child body position\nqc: child body orientation\n\n\n\n\n\n","category":"function"},{"location":"api.html#Representations","page":"API Documentation","title":"Representations","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"State\nminimal_to_maximal\nmaximal_to_minimal","category":"page"},{"location":"api.html#Dojo.State","page":"API Documentation","title":"Dojo.State","text":"State{T} \n\nstate information in maximal coordinates for Body at time steps: 1, 2, 3. \ninformation at time step 3 is recovered using configurations at time step 2 and velocities at time step 2.5.\n\nx1: position at previous time step\nq1: orientation (Quaternion) at previous time step \nv15: linear velocity at time step 1.5 (midpoint)\nω15: angular velocity at time step 1.5 (midpoint)\n\nx2: position at current time step \nq2: orientation (Quaternion) at current time step \nJF2: linear impulse (force * time step) applied at current time step \nJτ2: angular impulse (torque * timestep) applied at current time step \nFext: external force applied at current time step \nτext: external torque applied at current time step \n\nvsol: linear velocity at time step 2.5 (midpoint); contains current value (index 1) and candidate value (index 2)\nωsol: angular velocity at time step 2.5 (midpoint); contains current value (index 1) and candidate value (index 2)\n\nd: implicit dynamics evaluator (zero vector indicates physics are satisfied)\nD: Jacobian of implicit dynamics\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.minimal_to_maximal","page":"API Documentation","title":"Dojo.minimal_to_maximal","text":"minimal_to_maximal(mechanism, y)\n\nconvert minimal to maximal representation\n\nmechanism: Mechanism\ny: minimal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.maximal_to_minimal","page":"API Documentation","title":"Dojo.maximal_to_minimal","text":"maximal_to_minimal(mechanism, z)\n\nconvert maximal to minimal representation\n\nmechanism: Mechanism\nz: maximal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Mechanics","page":"API Documentation","title":"Mechanics","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"mechanical_energy \nkinetic_energy \npotential_energy \nmomentum","category":"page"},{"location":"api.html#Dojo.mechanical_energy","page":"API Documentation","title":"Dojo.mechanical_energy","text":"mechanical_energy(mechanism, storage)\n\nmechanism's total mechanical energy\n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.kinetic_energy","page":"API Documentation","title":"Dojo.kinetic_energy","text":"kinetic_energy(mechanism, storage)\n\nmechanism's kinetic energy from linear and angular velocity\n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.potential_energy","page":"API Documentation","title":"Dojo.potential_energy","text":"potential_energy(mechanism, storage)\n\nmechanism's potential energy from gravity and springs\n\nmechanism: Mechanism \nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.momentum","page":"API Documentation","title":"Dojo.momentum","text":"momentum(mechanism, storage)\n\nmechanism's linear and angular momentum\n\nmechanism: Mechanism\nstorage: Storage\n\n\n\n\n\n","category":"function"},{"location":"api.html#Simulate","page":"API Documentation","title":"Simulate","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"Storage\nstep!\nstep_minimal_coordinates!\nsimulate!","category":"page"},{"location":"api.html#Dojo.Storage","page":"API Documentation","title":"Dojo.Storage","text":"Storage{T,N}\n\ncontains maximal-representation trajectories\n\nx: position \nq: orientation (Quaternion)\nv: linear velocity (midpoint) \nω: angular velocity (midpoint)\npx: linear momentum\npq: angular momentum \nvl: linear velocity\nωl: angular velocity\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.step!","page":"API Documentation","title":"Dojo.step!","text":"step!(mechanism::Mechanism{T}, z::Vector{T}, u::Vector{T}; opts)\n\nsimulate mechanism for one time step provided maximal coordinates\n\nmechanism: Mechanism\nz: maximal state \nu: inputs\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.step_minimal_coordinates!","page":"API Documentation","title":"Dojo.step_minimal_coordinates!","text":"step_minimal_coordinates!(mechanism::Mechanism{T}, x::Vector{T}, u::Vector{T}; opts)\n\nsimulate mechanism for one time step provided minimal coordinates\n\nmechanism: Mechanism\nx: minimal state \nu: inputs\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.simulate!","page":"API Documentation","title":"Dojo.simulate!","text":"simulate!(mechanism, steps, storage, control!;\n    record, verbose, abort_upon_failure, opts)\n\nsimulate a mechanism\n\nmechanism: Mechanism \nsteps: range of steps to simulate \nstorage: Storage\ncontrol!: Function setting inputs for mechanism\nrecord: flag for recording simulation to storage\nverbose: flag for printing during simulation \nabort_upon_failure: flag for terminating simulation is solver fails to meet tolerances\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Gradients","page":"API Documentation","title":"Gradients","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"get_maximal_gradients!\nget_minimal_gradients!\nmaximal_to_minimal_jacobian\nminimal_to_maximal_jacobian","category":"page"},{"location":"api.html#Dojo.get_maximal_gradients!","page":"API Documentation","title":"Dojo.get_maximal_gradients!","text":"get_maximal_gradients!(mechanism, z, u; opts)\n\nreturn maximal gradients for mechanism\nnote: this requires simulating the mechanism for one time step\n\nmechanism: Mechanism\nz: state\nu: input\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.get_minimal_gradients!","page":"API Documentation","title":"Dojo.get_minimal_gradients!","text":"get_minimal_gradients!(mechanism, y, u; opts)\n\nreturn minimal gradients for mechanism\nnote: this requires simulating the mechanism for one time step\n\nmechanism: Mechanism\ny: state\nu: input\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.maximal_to_minimal_jacobian","page":"API Documentation","title":"Dojo.maximal_to_minimal_jacobian","text":"maximal_to_minimal_jacobian(mechanism, z)\n\nJacobian of mapping from maximal to minimal representation\n\nmechanism: Mechanism\nz: maximal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.minimal_to_maximal_jacobian","page":"API Documentation","title":"Dojo.minimal_to_maximal_jacobian","text":"minimal_to_maximal_jacobian(mechanism, x)\n\nJacobian of mapping from minimal to maximal representation\n\nmechanism: Mechanism\ny: minimal state\n\n\n\n\n\n","category":"function"},{"location":"api.html#Solver","page":"API Documentation","title":"Solver","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"SolverOptions\nmehrotra!","category":"page"},{"location":"api.html#Dojo.SolverOptions","page":"API Documentation","title":"Dojo.SolverOptions","text":"SolverOptions{T}\n\nOptions and tolerances of primal-dual interior point solver.\n\nrtol: tolerance on residual violations (equality constraints); defaults to 1e-6\nbtol: tolerance on bilinear violations (complementarity constraints); defaults to 1e-4\nls_scale: line search scaling factor (α_new ← ls_scale * α_current); defaults to 0.5\nmax_iter: maximum number of Newton iterations; defaults to 50\nmax_ls: maximum number of line search steps; defaults to 10\nundercut: complementarity slackness target; solver will aim at reaching complementarity violation = btol / undercut; defaults to Inf\nno_progress_max: number of Newton's iterations without progress trigerring the rescaling of the target complementarity violation; defaults to 3\nno_progress_undercut: undercut scaling factor (target_new ← target_current / no_progress_undercut); defaults to 10\nverbose: flag for printing the status of the solver during the solve; defaults to false\n\n\n\n\n\n","category":"type"},{"location":"api.html#Dojo.mehrotra!","page":"API Documentation","title":"Dojo.mehrotra!","text":"mehrotra!(mechanism; opts)\n\ninterior-point solver for simulation-step feasibility problem\n\nmechanism: Mechanism\nopts: SolverOptions\n\n\n\n\n\n","category":"function"},{"location":"api.html#Visualization","page":"API Documentation","title":"Visualization","text":"","category":"section"},{"location":"api.html","page":"API Documentation","title":"API Documentation","text":"visualize\nbuild_robot\nset_camera!\nset_light!\nset_surface!\nset_floor!\nset_arrow!","category":"page"},{"location":"api.html#Dojo.visualize","page":"API Documentation","title":"Dojo.visualize","text":"visualize(mechanism, storage; vis, build, show_contact, animation, color, name)\n\nvisualize mechanism using trajectory from storage \n\nmechanism: Mechanism \nstorage: Storage \nvis: Visualizer \nbuild: flag to construct mechanism visuals (only needs to be built once)\nshow_contact: flag to show contact locations on system \ncolor: RGBA \nname: unique identifier for mechanism\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.build_robot","page":"API Documentation","title":"Dojo.build_robot","text":"build_robot(mechanism; vis, show_contact, name, color)\n\nconstruct visuals for mechanism \n\nmechanism: Mechanism \nvis: Visualizer \nshow_contact: flag to show contact locations on mechanism \nname: unique identifier \ncolor: RGBA\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_camera!","page":"API Documentation","title":"Dojo.set_camera!","text":"set_camera!(vis; zoom, cam_pos)\n\nposition and zoom for camera in visualization\n\nvis: Visualizer\nzoom: value for zoom\ncam_pos: position of camera\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_light!","page":"API Documentation","title":"Dojo.set_light!","text":"set_light!(vis; ambient, fill, pointX, pointXshadow, direction)\n\nlighting conditions for visualization\n\nvis: Visualizer\nambient: value for ambient lighting\ndirection: positive or negative direction for light\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_surface!","page":"API Documentation","title":"Dojo.set_surface!","text":"set_surface!(vis; f, xlims, ylims, color, n)\n\nadds surface to visualization\n\nvis::Visualizer\nf: implicit function representing surface\nxlims: lateral domain for surface\nylims: longitudinal domain for surface\ncolor: RGBA\nn: number of discretization points along each domain\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_floor!","page":"API Documentation","title":"Dojo.set_floor!","text":"set_floor!(vis; x, y, z, origin, normal, color, tilepermeter, imagename, axis, grid)\n\nadds floor to visualization\n\nvis::Visualizer\nx: lateral position\ny: longitudinal position\nz: vertical position\norigin:: position of the center of the floor\nnormal:: unit vector indicating the normal to the floor\ncolor: RGBA\ntilepermeter: scaling\nimagename: path to image\naxis: flag to turn on visualizer axis\ngrid: flag to turn on visualizer grid\n\n\n\n\n\n","category":"function"},{"location":"api.html#Dojo.set_arrow!","page":"API Documentation","title":"Dojo.set_arrow!","text":"set_arrow!(vis, origin, direction; color, shaft_radius, max_head_radius, scaling, name)\n\nadds an arrow object to scene \n\nvis: Visualizer \norigin: point defining arrow base \ndirection: vector defining arrow \ncolor: RGBA \nshaft_radius: dimension of arrow shaft \nmax_head_radius: dimension of arrow head base \nscaling: parameter that scales the entire arrow \nname: Symbol\n\n\n\n\n\n","category":"function"},{"location":"creating_simulation/simulation_with_gradients.html#Gradients","page":"Gradients","title":"Gradients","text":"","category":"section"},{"location":"creating_simulation/simulation_with_gradients.html","page":"Gradients","title":"Gradients","text":"Dynamical systems, i.e., Mechanisms can be differentiated with respect to current state and control input. The results can be used, for example, for defining a linear controller. As an example, we use the ControlSystemsBase package to control the cartpole.","category":"page"},{"location":"creating_simulation/simulation_with_gradients.html","page":"Gradients","title":"Gradients","text":"# ### Setup\nusing Dojo\nusing DojoEnvironments\nusing ControlSystemsBase\nusing LinearAlgebra\n\n# ### Mechanism\nmechanism = get_mechanism(:cartpole)\n\n# ### Controller\nx0 = zeros(4)\nu0 = zeros(2)\nA, B = get_minimal_gradients!(mechanism, x0, u0)\nQ = I(4)\nR = I(1)\nK = lqr(Discrete,A,B[:,1],Q,R)\n\nfunction controller!(mechanism, k)\n    ## Target state\n    x_goal = [0;0; 0.0;0]\n\n    ## Current state\n    x = get_minimal_state(mechanism)\n\n    ## Control inputs\n    u = -K * (x - x_goal)\n    set_input!(mechanism, [u;0]) # input only to cart\nend\n\n# ### Simulate \ninitialize!(mechanism, :cartpole; position=0, orientation=pi/4)\n            \nstorage = simulate!(mechanism, 10.0, controller!, record=true)\n\n    \n# ### Visualize\nvis = visualize(mechanism, storage)\nrender(vis)","category":"page"},{"location":"creating_mechanism/mechanism_existing.html#Using-an-Existing-Mechanism","page":"Using an Existing Mechanism","title":"Using an Existing Mechanism","text":"","category":"section"},{"location":"creating_mechanism/mechanism_existing.html","page":"Using an Existing Mechanism","title":"Using an Existing Mechanism","text":"The following code uses a function defined in DojoEnvironments to create a pendulum Mechanism. As before, the mechanism consists of an Origin, a Body, and a JointConstraint. You can, of course, use these existing templates as a starting point for your own Mechanisms.","category":"page"},{"location":"creating_mechanism/mechanism_existing.html","page":"Using an Existing Mechanism","title":"Using an Existing Mechanism","text":"# ### Setup\nusing Dojo\nusing DojoEnvironments\n\n# ### Get mechanism (check DojoEnvironment/mechanisms files for kwargs)\nmechanism = get_mechanism(:pendulum; timestep=0.02, length=0.75) ","category":"page"},{"location":"background_contact/impact.html#Impact","page":"Impact","title":"Impact","text":"","category":"section"},{"location":"background_contact/impact.html#Mathematical-Model","page":"Impact","title":"Mathematical Model","text":"","category":"section"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"We model hard contact via constraints on the system’s configuration and the applied contact forces. For a system with P contact points, we define a signed-distance function,","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"phi  mathbfZ rightarrow mathbfR^P","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"subject to the following element-wise constraint:","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"ϕ(z)  0","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"Impact forces with magnitude gamma in mathbfR^P are applied to the bodies’ contact points in the direction of their surface normals in order to enforce (5) and prevent interpenetration. A non-negative constraint,","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"gamma geq 0","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"enforces physical behavior that impulses are repulsive (e.g., the floor does not attract bodies), and the complementarity condition,","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"gamma circ phi(z) = 0","category":"page"},{"location":"background_contact/impact.html","page":"Impact","title":"Impact","text":"where circ is an element-wise product operator, enforces zero force if the body is not in contact and allows non-zero force during contact.","category":"page"},{"location":"creating_simulation/define_controller.html#Defining-a-Controller","page":"Defining a Controller","title":"Defining a Controller","text":"","category":"section"},{"location":"creating_simulation/define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"Here, we explain how to write a controller and simulate its effect on a dynamical system, i.e., a Mechanism. We focus on the stabilization of the cartpole, which has two joints but only a single input on the cart. The controller is a method that always takes 2 input arguments:","category":"page"},{"location":"creating_simulation/define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"a Mechanism,\nan integer k indicating the current simulation step.","category":"page"},{"location":"creating_simulation/define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"For the cartpole, the controller computes the control input based on the current state x, the goal state x_goal and an LQR controller. The simulation step is not used in this example.","category":"page"},{"location":"creating_simulation/define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"There are three ways to apply inputs to the system","category":"page"},{"location":"creating_simulation/define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"set an input directly to a joint\nset a set of inputs to all joints of the mechanism\nset an external force on bodies","category":"page"},{"location":"creating_simulation/define_controller.html","page":"Defining a Controller","title":"Defining a Controller","text":"# ### Setup\nusing Dojo\nusing DojoEnvironments\n\n# ### Mechanism\nmechanism = get_mechanism(:cartpole)\n\n# ### Controller\nK = [-0.948838; -2.54837; 48.6627; 10.871]\n\nfunction controller!(mechanism, k)\n    ## Target state\n    x_goal = [0;0; 0.0;0]\n\n    ## Current state\n    x = get_minimal_state(mechanism)\n\n    ## Control inputs\n    u = -K' * (x - x_goal)\n\n    ## 3 ways to set input:\n\n    ## 1: get joint and set input\n    cart_joint = get_joint(mechanism, :cart_joint)\n    set_input!(cart_joint, [u])\n\n    ## 2: set input for all joints at once\n    ## set_input!(mechanism, [u;0]) # need to know joint order\n\n    ## 3: direct external force on body\n    ## cart = get_body(mechanism, :cart)\n    ## set_external_force!(cart; force=[0;u;0])\n\nend\n\n# ### Simulate \ninitialize!(mechanism, :cartpole; position=0, orientation=pi/4)\n            \nstorage = simulate!(mechanism, 10.0, controller!, record=true)\n\n    \n# ### Visualize\nvis = visualize(mechanism, storage)\nrender(vis)","category":"page"},{"location":"background_contact/nonlinear_friction.html#Nonlinear-friction","page":"Nonlinear friction","title":"Nonlinear friction","text":"","category":"section"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"In contrast to a LCP approach, we utilize the optimality conditions of in a form amenable to a primal-dual interior-point solver. The associated cone program is,","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beginalign*\nundersetbetatextminimize  hspace05em beginbmatrix 0  v^T endbmatrix beta\ntextsubject to  hspace05em beta_(1) = mu gamma \n hspace05em beta in mathcalQ^3\nendalign*","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"where subscripts indicate vector indices and the n-dimensional second-order cone mathcalQ^n is defined by:","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"mathcalQ^n = (a_(1) a_(2n)) in mathbfR times mathbfR^n-1   a_(2n)_2 leq a_(1) ","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"The relaxed optimality conditions for the above problem in interior-point form are:","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beginalign* \nv - eta_(23) = 0 \nbeta_(1) - mu gamma = 0 \nbeta circ eta =  kappa mathbfe \nbeta eta in mathcalQ^3\nendalign*","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"with dual variable eta in mathcalQ^3 associated with the second-order-cone constraints, and central-path parameter, kappa in mathbfR_+. The second-order-cone product is:","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beta circ eta = (beta^T eta beta_(1) eta_(2n) + eta_(1) beta_(2n))","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"and,","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"mathbfe = (1 0 dots 0)","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"is its corresponding identity element. Friction is recovered from the solution: b = beta^*_(23). The benefits of this model are increased physical fidelity and fewer optimization variables, without substantial increase in computational cost.","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"Nonlinear complementarity problem: To simulate a system represented in maximal coordinates that experiences contact, a solver aims to satisfy the following relaxed feasibility problem:","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"beginalign*\ntextfind  quad z_+ w gamma beta^(1P) eta^(1P) s\ntextst  quad f(z_- z z_+ w) + B(z) u + C(z)^T lambda = 0 \n quad s - phi(z_+) = 0 \n quad gamma circ s = kappa textbf1 \n quad beta^(i) circ eta^(i) = kappa mathbfe  quad i = 1 dots P\n quad v^(i)(z z_+) - eta_(23)^(i) = 0  quad i = 1 dots P \n quad beta^(i)_(1) - mu^(i) gamma^(i) = 0  quad i = 1 dots P\n quad gamma s geq 0\n quad beta^(i) eta^(i) in mathcalQ^3  quad i = 1 dots P\nendalign*","category":"page"},{"location":"background_contact/nonlinear_friction.html","page":"Nonlinear friction","title":"Nonlinear friction","text":"where u in mathbfR^m is the control input at the current time step, lambda = (beta^(1)_(23) gamma^(1) dots beta^(P)_(23) gamma^(P)) in mathbfLambda is the concatenation of impact and friction impulses, B  mathbfZ rightarrow mathbfR^6N times m is the input Jacobian mapping control inputs into maximal coordinates, C  mathbfZ rightarrow mathbfR^textdim(mathbfLambda) times 6N is a contact Jacobian mapping between maximal coordinates and contact surfaces, s in mathbfR^P is a slack variable introduced for convenience, and v^(i)  mathbfZ times mathbfZ rightarrow mathbfR^2 is the tangential velocity at contact point i. Joint limits and internal friction are readily incorporated into this problem formulation.","category":"page"},{"location":"background_representations/gradients.html#Background-on-Gradients","page":"Background on Gradients","title":"Background on Gradients","text":"","category":"section"},{"location":"background_representations/gradients.html#Implicit-Function-Theorem","page":"Background on Gradients","title":"Implicit Function Theorem","text":"","category":"section"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"An implicit function, r  mathbfR^n_w times mathbfR^n_theta rightarrow mathbfR^n_w, is defined as","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"r(w^* theta) = 0","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"for solution w^* in mathbfR^n_w and problem data theta in mathbfR^n_theta. At a solution point of the above equation the sensitivities of the solution with respect to the problem data, i.e., partial w^*  partial theta, can be computed under certain conditions. First, we approximate the above equation to first order:","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"  fracpartial rpartial w delta w + fracpartial rpartial theta delta theta = 0","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"and then solve for the relationship:","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"fracpartial w^*partial theta = -Big(fracpartial rpartial wBig)^-1 fracpartial rpartial theta quad quad(1)","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"In case (partial r  partial w)^-1 is not well defined, (e.g., not full rank) we can either apply regularization or approximately solve (1) with, for example, a least-squares approach.","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"Often, Newton's method is employed to find solutions to the implicit equation and custom linear-system solvers can efficiently compute search directions for this purpose. Importantly, the factorization of partial r  partial w used to find a solution can be reused to compute (1) at very low computational cost using only back-substitution. Additionally, each element of the problem-data sensitivity can be computed in parallel.","category":"page"},{"location":"background_representations/gradients.html#Dojo's-Gradient","page":"Background on Gradients","title":"Dojo's Gradient","text":"","category":"section"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"At a solution point, w^*(theta kappa), the sensitivity of the solution with respect to the problem data, i.e., partial w^*  partial theta, is efficiently computed using the implicit-function theorem (1) to differentiate through the solver's residual.","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"The efficient linear-system solver used for the simulator, as well as the computation and factorization of partial r  partial w, is used to compute the sensitivities for each element of the problem data. Calculations over the individual columns of partial r  partial theta can be performed in parallel.","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"The problem data for each simulation step include: the previous and current configurations, control input, and additional terms like the time step, friction coefficients, and parameters of each body. The chain rule is utilized to compute gradients with respect to the finite-difference velocities as well as transformations between minimal- and maximal-coordinate representations.","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"In many robotics scenarios, we are interested in gradient information through contact events. Instead of computing gradients for hard contact with zero or very small central-path parameters, we use a relaxed value from intermediate solutions w^*(theta kappa  0) corresponding to a soft contact model. In practice, we find that these smooth gradients greatly improve the performance of gradient-based optimization methods.","category":"page"},{"location":"background_representations/gradients.html#Gradient-Comparison","page":"Background on Gradients","title":"Gradient Comparison","text":"","category":"section"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"<img src=\"../assets/pictures/gradient_comparison.png\" width=\"500\"/>","category":"page"},{"location":"background_representations/gradients.html","page":"Background on Gradients","title":"Background on Gradients","text":"Gradient comparison between randomized smoothing and Dojo's smooth gradients. The dynamics for a box in the XY plane that is resting on a flat surface and displaced an amount Delta by an input F (top left). Its corresponding exact gradients are shown in black. Gradient bundles (right column) are computed using sampling schemes with varying covariances Sigma and 500 samples. Dojo's gradients (middle column) are computed for different values of kappa, corresponding to the smoothness of the contact model. Compared to the 500-sample gradient bundle, Dojo's gradients are not noisy and are a 100 times faster to compute with a single worker.","category":"page"},{"location":"creating_mechanism/mechanism_directly.html#Directly-Build-a-Mechanism","page":"Directly Build a Mechanism","title":"Directly Build a Mechanism","text":"","category":"section"},{"location":"creating_mechanism/mechanism_directly.html","page":"Directly Build a Mechanism","title":"Directly Build a Mechanism","text":"The following code builds a pendulum Mechanism, consisting of an Origin, a Body, and a JointConstraint. Most Mechanisms consist of these three components, sometimes supplemented by ContactConstraints. ","category":"page"},{"location":"creating_mechanism/mechanism_directly.html","page":"Directly Build a Mechanism","title":"Directly Build a Mechanism","text":"# ### Setup\nusing Dojo\n\n# ### Parameters\nradius = 0.1\nlength = 1\nmass = 1\nrotation_axis = [1;0;0] \nconnection = [0;0;length/2]\n\n# ### Mechanism components\norigin = Origin()\nbody = Cylinder(radius, length, mass)\njoint = JointConstraint(Revolute(origin, body, rotation_axis; child_vertex=connection))\n\n# ### Construct Mechanism\nmechanism = Mechanism(origin, [body], [joint])","category":"page"},{"location":"creating_simulation/define_simulation.html#Defining-a-Simulation","page":"Defining a Simulation","title":"Defining a Simulation","text":"","category":"section"},{"location":"creating_simulation/define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"Here, we explain how to simulate a dynamical system i.e., a Mechanism forward in time. The example that we are trying to replicate the Dzhanibekov effect shown below.","category":"page"},{"location":"creating_simulation/define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"(Image: dzhanibekov)","category":"page"},{"location":"creating_simulation/define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"# ### Setup\nusing Dojo\nusing DojoEnvironments\n\n# ### Get mechanism (check DojoEnvironment/mechanisms files for kwargs)\nmechanism = get_mechanism(:dzhanibekov; timestep=0.01, gravity=0) \n\n# ### Initialize mechanism (check DojoEnvironment/mechanisms files for kwargs)\ninitialize!(mechanism, :dzhanibekov; angular_velocity=[15.0; 0.01; 0.0])\n\n# ### Simulate mechanism\nstorage = simulate!(mechanism, 5, record=true)\n    \n# ### Visualize mechanism\nvis = visualize(mechanism, storage)\nrender(vis)","category":"page"},{"location":"creating_simulation/define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"And voila! You should see something like this;","category":"page"},{"location":"creating_simulation/define_simulation.html","page":"Defining a Simulation","title":"Defining a Simulation","text":"<img src=\"../assets/animations/dzhanibekov.gif\" width=\"300\"/>","category":"page"},{"location":"creating_mechanism/tippetop.html#Detailed-Mechanism-Definition","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"","category":"section"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"Here, we describe in detail how to define your own dynamical system of Mechanism. After it has been defined, it will be extremely easy to simulate it, control it, perform trajectory optimization on it, or even policy optimization.","category":"page"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"We're going to build a tippe top:","category":"page"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"<img src=\"../assets/animations/tippetop_real.gif\" width=\"300\"/>","category":"page"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"<img src=\"../assets/animations/tippetop.gif\" width=\"300\"/>","category":"page"},{"location":"creating_mechanism/tippetop.html#Build-Mechanism","page":"Detailed Mechanism Definition","title":"Build Mechanism","text":"","category":"section"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"We will take a look at the definition of get_tippetop in DojoEnvironments. This function return a Mechanism and takes as input a variety of parameters like the simulation time step, gravity etc. You can add as many parameters you want. This example is typical of what you will find in Dojo.","category":"page"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"To build the mechanism corresponding to the tippe top, we decompose it into two spherical bodies. Each body has its own spherical contact constraint with the floor. The joint between the two bodies is a Fixed joint and the joint between the main body and the Origin of the frame is a Floating joint.","category":"page"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"function get_tippetop(;\n    timestep=0.01,\n    input_scaling=timestep, \n    gravity=-9.81,\n    mass=1,\n    radius=0.5,\n    scale=0.2,\n    color=RGBA(0.9, 0.9, 0.9, 1.0),\n    springs=0,\n    dampers=0, \n    limits=false,\n    joint_limits=Dict(),\n    keep_fixed_joints=false, \n    friction_coefficient=0.4,\n    contact=true,\n    contact_type=:nonlinear,\n    T=Float64)\n\n    # mechanism\n    origin = Origin{T}(name=:origin)\n    \n    bodies = [\n        Sphere(radius, mass; name=:sphere1, color),\n        Sphere(radius*scale, mass*scale^3; name=:sphere2, color)\n    ]\n    bodies[1].inertia = Diagonal([1.9, 2.1, 2])\n\n    joints = [\n        JointConstraint(Floating(origin, bodies[1]); name=:floating_joint),\n        JointConstraint(Fixed(bodies[1], bodies[2];\n            parent_vertex=[0,0,radius]), name = :fixed_joint)\n    ]\n\n    mechanism = Mechanism(origin, bodies, joints;\n        timestep, gravity, input_scaling)\n\n    # springs and dampers\n    set_springs!(mechanism.joints, springs)\n    set_dampers!(mechanism.joints, dampers)\n\n    # joint limits    \n    if limits\n        joints = set_limits(mechanism, joint_limits)\n\n        mechanism = Mechanism(mechanism.origin, mechanism.bodies, joints;\n            gravity, timestep, input_scaling)\n    end\n    \n    # contacts\n    contacts = ContactConstraint{T}[]\n\n    if contact\n        n = length(bodies)\n        normals = fill(Z_AXIS,n)\n        friction_coefficients = fill(friction_coefficient,n)\n        contact_radii = [radius;radius*scale]\n        contacts = [contacts;contact_constraint(bodies, normals; friction_coefficients, contact_radii, contact_type)]\n    end\n\n    mechanism = Mechanism(mechanism.origin, mechanism.bodies, mechanism.joints, contacts;\n        gravity, timestep, input_scaling)\n\n    # zero configuration\n    initialize_tippetop!(mechanism)\n\n    # construction finished\n    return mechanism\nend","category":"page"},{"location":"creating_mechanism/tippetop.html#Initialize-Mechanism","page":"Detailed Mechanism Definition","title":"Initialize Mechanism","text":"","category":"section"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"The second method that we need to look at is initialize_tippetop!. This function initialize the dynamical system to a certain state. This means that we set the position orientation, linear and angular velocity of each body in the mechanism.","category":"page"},{"location":"creating_mechanism/tippetop.html","page":"Detailed Mechanism Definition","title":"Detailed Mechanism Definition","text":"function initialize_tippetop!(mechanism::Mechanism{T};\n    body_position=2*Z_AXIS*mechanism.bodies[1].shape.r, body_orientation=one(Quaternion),\n    body_linear_velocity=zeros(3), body_angular_velocity=[0.0, 0.1, 50.0]) where T\n\n    # zero state\n    zero_velocities!(mechanism)\n    zero_coordinates!(mechanism)\n\n    # set desired state value \n    floating_joint = mechanism.joints[1]\n    set_minimal_coordinates!(mechanism, floating_joint, \n        [body_position; Dojo.rotation_vector(body_orientation)])\n    set_minimal_velocities!(mechanism, floating_joint, \n        [body_linear_velocity; body_angular_velocity])\nend","category":"page"},{"location":"creating_mechanism/quadruped.html#Loading-a-Mechanism-via-URDF","page":"Loading a Mechanism via URDF","title":"Loading a Mechanism via URDF","text":"","category":"section"},{"location":"creating_mechanism/quadruped.html","page":"Loading a Mechanism via URDF","title":"Loading a Mechanism via URDF","text":"Another way to build a mechanism is to directly load it from a URDF file. We illustrate this with the A1 quadruped, defined in DojoEnvironments. ","category":"page"},{"location":"creating_mechanism/quadruped.html","page":"Loading a Mechanism via URDF","title":"Loading a Mechanism via URDF","text":"(Image: quadruped)","category":"page"},{"location":"creating_mechanism/quadruped.html","page":"Loading a Mechanism via URDF","title":"Loading a Mechanism via URDF","text":"Note that the Mechanism is created simply by passing the path to the URDF file to the constructor. Afterwards, additional features, such as contacts can be added. ","category":"page"},{"location":"creating_mechanism/quadruped.html","page":"Loading a Mechanism via URDF","title":"Loading a Mechanism via URDF","text":"function get_quadruped(;\n    timestep=0.01,\n    input_scaling=timestep, \n    gravity=-9.81,\n    urdf=:gazebo_a1, \n    springs=0,\n    dampers=0,\n    parse_springs=true, \n    parse_dampers=true,\n    limits=true,\n    joint_limits=Dict(vcat([[\n        (Symbol(group,:_hip_joint), [-0.5,0.5]), \n        (Symbol(group,:_thigh_joint), [-0.5,1.5]), \n        (Symbol(group,:_calf_joint), [-2.5,-1])] \n        for group in [:FR, :FL, :RR, :RL]]...)),\n    keep_fixed_joints=true, \n    friction_coefficient=0.8,\n    contact_feet=true,\n    contact_body=true,\n    T=Float64)\n\n    # mechanism\n    path = joinpath(@__DIR__, \"dependencies/$(string(urdf)).urdf\")\n    mechanism = Mechanism(path; floating=true, T,\n        gravity, timestep, input_scaling, \n        parse_dampers, keep_fixed_joints)\n\n    # springs and dampers\n    !parse_springs && set_springs!(mechanism.joints, springs)\n    !parse_dampers && set_dampers!(mechanism.joints, dampers)\n\n    # joint limits\n    if limits\n        joints = set_limits(mechanism, joint_limits)\n\n        mechanism = Mechanism(mechanism.origin, mechanism.bodies, joints;\n            gravity, timestep, input_scaling)\n    end\n\n    # contacts\n    contacts = ContactConstraint{T}[]\n\n    if contact_feet\n        # feet contacts\n        body_names = [:FR_calf, :FL_calf, :RR_calf, :RL_calf]\n        names = [:FR_calf_contact, :FL_calf_contact, :RR_calf_contact, :RL_calf_contact]\n        contact_bodies = [get_body(mechanism, name) for name in body_names]\n        n = length(contact_bodies)\n        normals = fill(Z_AXIS,n)\n        friction_coefficients = fill(friction_coefficient,n)\n        contact_origins = fill([-0.006; 0; -0.092],n)\n        contact_radii = fill(0.021,n)\n        contacts = [contacts;contact_constraint(contact_bodies, normals; friction_coefficients, contact_origins, contact_radii, names)]\n    end\n\n    if contact_body\n        # thigh contacts\n        body_names = [:FR_thigh, :FL_thigh, :RR_thigh, :RL_thigh]\n        names = [:FR_thigh_contact, :FL_thigh_contact, :RR_thigh_contact, :RL_thigh_contact]\n        contact_bodies = [get_body(mechanism, name) for name in body_names]\n        n = length(contact_bodies)\n        normals = fill(Z_AXIS,n)\n        friction_coefficients = fill(friction_coefficient,n)\n        contact_origins = [\n            [-0.005; -0.023; -0.16],\n            [-0.005; 0.023; -0.16],\n            [-0.005; -0.023; -0.16],\n            [-0.005; 0.023; -0.16],\n        ]\n        contact_radii = fill(0.023,n)\n        contacts = [contacts;contact_constraint(contact_bodies, normals; friction_coefficients, contact_origins, contact_radii, names)]\n    \n        # hip contacts\n        body_names = [:FR_hip, :FL_hip, :RR_hip, :RL_hip]\n        names = [:FR_hip_contact, :FL_hip_contact, :RR_hip_contact, :RL_hip_contact]\n        contact_bodies = [get_body(mechanism, name) for name in body_names]\n        n = length(contact_bodies)\n        normals = fill(Z_AXIS,n)\n        friction_coefficients = fill(friction_coefficient,n)\n        contact_origins = fill([0; 0.05; 0],n)\n        contact_radii = fill(0.05,n)\n        contacts = [contacts;contact_constraint(contact_bodies, normals; friction_coefficients, contact_origins, contact_radii, names)]\n    end\n\n    mechanism = Mechanism(mechanism.origin, mechanism.bodies, mechanism.joints, contacts;\n        gravity, timestep, input_scaling)\n\n    # zero configuration\n    initialize_quadruped!(mechanism)\n\n    # construction finished\n    return mechanism\nend","category":"page"},{"location":"creating_mechanism/quadruped.html","page":"Loading a Mechanism via URDF","title":"Loading a Mechanism via URDF","text":"function initialize_quadruped!(mechanism::Mechanism;\n    body_position=[0, 0, 0], body_orientation=one(Quaternion),\n    hip_angle=0, thigh_angle=pi/4, calf_angle=-pi/2)\n\n    zero_velocities!(mechanism)\n    zero_coordinates!(mechanism)\n\n    body_position += [0, 0, 0.43]\n    set_minimal_coordinates!(mechanism, get_joint(mechanism, :floating_base), [body_position; Dojo.rotation_vector(body_orientation)])\n    for group in [:FR, :FL, :RR, :RL]\n        set_minimal_coordinates!(mechanism, get_joint(mechanism, Symbol(group, :_hip_joint)), [hip_angle])\n        set_minimal_coordinates!(mechanism, get_joint(mechanism, Symbol(group, :_thigh_joint)), [thigh_angle])\n        set_minimal_coordinates!(mechanism, get_joint(mechanism, Symbol(group, :_calf_joint)), [calf_angle])\n    end\n\n    return\nend\n","category":"page"},{"location":"index.html#Get-Started","page":"Get Started","title":"Get Started","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Dojo is a differentiable simulator for robotics, prioritizing accurate physics and useful gradients. The simulator is written in pure Julia in order to be both performant and easy to use.","category":"page"},{"location":"index.html#Features","page":"Get Started","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Maximal-Coordinates Representation: Fast and efficient conversion between maximal and minimal representations\nSmooth Gradients: Simulation with hard contact and useful gradients through contact events\nOpen Source: Code is available on GitHub and distributed under the MIT License\nPython Interface: dojopy","category":"page"},{"location":"index.html#Installation","page":"Get Started","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Dojo can be installed using the Julia package manager for Julia v1.6 and higher. Inside the Julia REPL, type ] to enter the Pkg REPL mode then run","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"pkg> add Dojo","category":"page"},{"location":"index.html#Related-talks","page":"Get Started","title":"Related talks","text":"","category":"section"},{"location":"index.html#Credits","page":"Get Started","title":"Credits","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"The following people are involved in the development of Dojo:","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Primary Development","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Simon Le Cleac'h (main development, contact modeling, interior-point solver, gradients)\nTaylor Howell (main development, contact modeling, interior-point solver, gradients)\nJan Bruedigam (main development, maximal representation and graph-based solver)","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Zico Kolter\nMac Schwager\nZachary Manchester (principal investigator)","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Additional Contributions","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Suvansh Sanjeev (PyTorch interface)\nBenjamin Bokser (REx Hopper)","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Development by the Robotic Exploration Lab.","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"If this project is useful for your work please consider","category":"page"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Citing the relevant papers\nLeaving a star on the GitHub repository","category":"page"},{"location":"index.html#Licence","page":"Get Started","title":"Licence","text":"","category":"section"},{"location":"index.html","page":"Get Started","title":"Get Started","text":"Dojo.jl is licensed under the MIT License. For more details click here.","category":"page"},{"location":"citing.html#Citing","page":"Citing","title":"Citing","text":"","category":"section"},{"location":"citing.html","page":"Citing","title":"Citing","text":"If you find Dojo useful in your project, we kindly request that you cite the following paper:","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"@article{howelllecleach2022dojo,\n\ttitle={Dojo: {A} {D}ifferentiable {S}imulator for {R}obotics},\n\tauthor={Howell, Taylor A. and Le Cleac'h, Simon and Bruedigam, Jan and Kolter, J. Zico and Schwager, Mac and Manchester, Zachary},\n\tyear={2022}\n}","category":"page"},{"location":"citing.html","page":"Citing","title":"Citing","text":"A preprint can be downloaded from arXiv.","category":"page"},{"location":"background_solver/interior_point.html#Algorithm","page":"Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"background_solver/interior_point.html#Overview","page":"Algorithm","title":"Overview","text":"","category":"section"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"To simulate the system forward in time, we need to solve a Nonlinear Complementarity Problem (NCP) at each time step. To efficiently and reliably satisfy the NCP, we developed a custom primal-dual interior-point solver for NCPs with cone constraints and quaternions. The algorithm is largely based upon Mehrotra's predictor-corrector algorithm, while borrowing practical numerical features from CVXOPT to handle cones and non-Euclidean optimization to handle quaternions. We also introduce heuristics that further improve reliability and overall performance of the solver for our simulation-step NCPs.","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"The primary advantages of this algorithm are the correction to the classic Newton step, which can greatly reduce the iterations required by the solver (often halving the total number of iterations), and feedback on the problem's central-path parameter that helps avoid premature ill-conditioning and adaptively drives the complementarity violation to zero in order to reliably simulate hard contact.","category":"page"},{"location":"background_solver/interior_point.html#Problem-formulation","page":"Algorithm","title":"Problem formulation","text":"","category":"section"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"The solver aims to satisfy instantiations of the following problem:","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"beginalign*\ntextfind  quad  x y z \ntextsubject to  quad  c(x y z theta) = 0 \n quad y^(i) circ z^(i) = kappa mathbfe  quad i = 1dotsn \n quad y^(i) z^(i) in mathcalK  quad i = 1dots n\nendalign*","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"with decision variables x in mathbfR^k and y z in mathbfR^m, equality-constraint set c  mathbfR^k times mathbfR^m times mathbfR^m times mathbfR^l rightarrow mathbfR^h, problem data theta in mathbfR^l; and where mathcalK is the Cartesian product of n total positive-orthant and second-order cones. The variables are partitioned: x = (x^(1) dots x^(p)), where i = 1 are Euclidean variables and i = 2 dots p are each quaternion variables; and y = (y^(1) dots y^(n)), z = (z^(1) dots z^(n)), where j = 1 is the positive-orthant and the remaining j = 2 dots n are second-order cones. For convenience, we denote w = (x y z).","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"The algorithm aims to satisfy a sequence of relaxed problems with kappa  0 and kappa rightarrow 0 in order to reliably converge to a solution of the original problem (i.e., kappa = 0). This continuation approach helps avoid premature ill-conditioning and is the basis for numerous convex and non-convex general-purpose interior-point solvers.","category":"page"},{"location":"background_solver/interior_point.html#Violation-metrics:","page":"Algorithm","title":"Violation metrics:","text":"","category":"section"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"Two metrics are used to measure progress: The constraint violation,","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"r_textvio =  c(w theta) _infty","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"and complementarity violation,","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"b_textvio = textmax_i  y^(i) circ z^(i) _infty","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"The NCP is considered solved when r_textvio  r_texttol and b_textvio  b_texttol.","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"info: solver options\nBoth r_tol and b_tol are options that can easily be accessed and modified via SolverOptions.","category":"page"},{"location":"background_solver/interior_point.html#Newton-Steps","page":"Algorithm","title":"Newton Steps","text":"","category":"section"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"The main loop of the solver performs Newton's method on the equality-constraint set c and the bilinear constraints. The solver typically converges in about 10 iterations.","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"info: solver options\nThe maximal number of Newton's iterations max_iter can be set via SolverOptions.","category":"page"},{"location":"background_solver/interior_point.html#Line-Search","page":"Algorithm","title":"Line Search","text":"","category":"section"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"Newton's method provides a search direction, then we perform a line search along this direction to determine the step length alpha. We use a backtracking line search that accepts the step whenever it decreases c_textvio or b_textvio. The line search starts with a step alpha=1, if the step acceptance conditions are not met the step is decreased geometrically: alpha leftarrow s cdot alpha. The line search takes at most max_ls backtracking steps.","category":"page"},{"location":"background_solver/interior_point.html","page":"Algorithm","title":"Algorithm","text":"info: solver options\nThe scaling parameter s is called ls_scale and the maximum number of line search iteration max_ls can be set via SolverOptions.","category":"page"}]
}
